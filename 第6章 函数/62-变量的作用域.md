##变量的作用域

&emsp;&emsp;在上一节中，读者可能想知道为什么需要利用函数交换数据。原因是C#中的变量仅能从代码的本地作用域访问。给定的变量有一个作用域，在这个作用域外是不能访问该变量的。

>&emsp;&emsp;变量的作用域是一个重要主题，最好用一个示例加以说明。下面的示例将演示在一个作用域中定义变量，但视图在另一个作用域中使用该变量的情形。

>```javascript
        class Program
        {
            static void Write()
            {
                Console.WriteLine("myString = {0}", myString);  ❌
            }

>            static void Main(string[] args)
            {
                string myString = "String defined in Main()";
                Write();
                Console.ReadKey();
            }
        }
```

>&emsp;&emsp;**示例的说明**

>&emsp;&emsp;什么地方出错了？不能在 `Write()` 函数中访问在应用程序主体( `Main()` 函数 )中定义的变量 `myString`。

>&emsp;&emsp;原因是变量是有作用域的，在这个作用域中，变量才是有效的。这个作用域包括定义变量的代码块和直接镶嵌在其中的代码块。函数中的代码块与调用它们的代码块是不同的。在 `Write()` 中，没有定义 `myString`，在 `Main()` 中定义的 `myString` 则超出了作用域--它只能在 `Main()` 中使用。

>&emsp;&emsp;实际上，在 `Write()` 中可以有一个完全独立的变量 `myString`。修改代码，如下所示：

>```javascript
        class Program
        {
            static void Write()
            {
                string myString = "String defined in Write()";
                Console.WriteLine("Now in Write()");
                Console.WriteLine("myString = {0}", myString);
            }

>             static void Main(string[] args)
            {
                string myString = "String defined in Main()";
                Write();
                Console.WriteLine("\nNow in Main()");
                Console.WriteLine("myString = {0}", myString);
                Console.ReadKey();
            }
        }
```

>&emsp;&emsp;这段代码执行的操作如下：

>* Main() 定义和初始化字符串变量 `myString`。
>* Main() 把控制权传给 `Write()`。 
>* Write() 定义和初始化字符串变量 `myString`，它与 `Main()` 中定义的 `myString` 变量完全不同。
>* Write() 把一个字符串输出到控制台上，该字符串包含在 `Write()` 中定义的 `myString` 的值。
>* Write() 把控制权传送回 `Main()`。
>* Main() 把一个字符串输出到控制台上，该字符串包含在 `Main()` 中定义的 `myString` 的值。





🔚